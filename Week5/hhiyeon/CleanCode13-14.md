### 📌 13장 동시성
#### 동시성이 필요한 이유?
- 동시성은 결합(coupling)을 없애는 전략이다.
- 무엇(what), 언제(when)를 분리하는 전략
- 작업 처리량(throughput)을 개선 해야 하는 경우, 다중 스레드 알고리즘으로 수집기 성능을 높일 수 있다.
- 한 번에 한 사용자를 처리하는 시스템인 경우, 사용자가 늘어나면 시스템 응답 속도가 느려진다. 많은 사용자를 동시에 처리하면 시스템 응답 시간 개선 가능
- 동시성은 항상 성능을 높여주지 않는다.
  - 동시성은 여러 개의 프로세서를 동시에 처리할 독립적인 계산이 많은 경우에만 성능이 높아진다.
- 동시성을 구현하면 설계가 변한다.
  - 단일 스레드 시스템과 다중 스레드 시스템은 설계가 판이하게 다르다. 
  - 일반적으로 무엇과 언제를 분리하면 시스템 구조가 크게 달라진다.
- 웹 또는 EJB 컨테이너를 사용하면 동시성을 이해할 필요가 없지 않다.
  - 컨테이너 동작 원리, 동시 수정 방법, 데드락 등과 같이 문제를 회피할 수 있는 지 알아야 한다.
- 동시성은 다소 부하를 유발한다.
  - 성능 측면 부하, 코드의 추가
- 동시성은 복잡하다.
- 일반적으로 동시성 버그는 재현하기 어렵다.
- 동시성을 구현하려면 흔히 근본적인 설계 전략을 재고해야 한다.

#### 동시성을 구현하기 어려운 이유
```java
public class X {
    private int lastldllsed;
    
    public int getNextId() { 
        return ++lastldllsed;
    } 
}
```
- astldUsed 필드를 42으로 설정하고, 두 스레드가 같은 변수를 동시 참조하면
- 한 스레드는 43를 받고, 다른 스레드도 43을 받는다. lastIdUsed는 43이 된다.

#### 동시성 방어 원칙
- 단일 책임 원칙(Single Responsibility Principle)
  - 주어진 메소드, 클래스, 컴포넌트를 변경할 이유가 하나여야 한다.
  - 동시성 관련 코드는 다른 코드와 분리한다.
- 따름 정리(corollary) : 자료 범위를 제한하라
  - 공유 객체를 사용하는 코드 내 임계영역(critical section)을 synchronized 키워드로 보호한다.
  - 자료를 캡슐화하고, 공유 자료를 최대한 줄여라
- 따름 정리 : 자료 사본을 사용하라
  - 공유 자료를 줄이려면 처음부터 공유하지 않는 방법이 제일 좋다.
  - 하지만 사본으로 동기화를 피하게 되면, 사본 생성과 가비지 컬렉션이 성능 부하를 상쇄할 수 있다.
- 따름 정리 : 스레드는 가능한 독립적으로 구현하라
  - 다른 스레드와 자료를 공유하지 않는다. 
  - 각 스레드는 클라이언트 요청 하나를 처리한다.
  - 모든 정보는 비공유 출처에서 가져오며 로컬 변수에 저장한다.

#### 라이브러리를 이해해라 - 스레드 환경에 안전한 컬렉션
- java.util.concurrent 패키지가 제공하는 클래스 
- 다중 스레드 환경에서 사용해도 안전하고, 성능이 좋다.
- ConcurrentHashMap은 거의 모든 상황에서 HashMap보다 빠르다.

#### 실행 모델을 이해해라
- 기본 용어
<br>
<img width="411" alt="스크린샷 2022-12-18 오후 7 00 18" src="https://user-images.githubusercontent.com/52193680/208292058-17a82c04-eff6-4e88-b363-70cab610c7f2.png">
<br>

#### 실행 모델 종류
- 생산자/소비자(Producer-Consumer)
  - 하나 이상 생산자 스레드가 정보를 생성해 버퍼(buffer)나 대기열(queue)에 넣는다.
  - 대기열은 한정된 자원
  - 생산자 스레드는 대기열에 빈 공간이 있어야 정보를 채우고, 소비자 스레드는 대기열에 정보가 있어야 가져온다.
  - 생산자 스레드와 소비자 스레드는 서로 대기열 정보에 관련한 시그널을 보낸다.
- 읽기/쓰기(Readers-Writers)
  - 읽기 스레드를 위해 공유 자원을 사용하게 되면, 쓰기 스레드가 이 공유 자원을 갱신할 때 처리율(throughput) 문제가 생길 수 있다. 
  - 처리율을 강조하면 기아(starvation) 현상이 생기거나 오래된 정보가 쌓인다.
  - 쓰기 스레드가 버퍼를 오랫동안 점유하게 되면 읽기 스레드는 버퍼를 기다리느라 처리율이 떨어진다.
- 식사하는 철학자들(Dining Philosophers)

#### 동기화하는 메소드 사이에 존재하는 의존성을 이해해라
- 공유 객체 하나에는 메소드 하나만 사용하기
- 공유 객체 하나에 여러 메소드가 필요한 경우
  - 클라이언트에서 잠금 : 클라이언트에서 첫 번째 메소드를 호출하기 전에 서버를 잠근다. 마지막 메소드를 호출할 때까지 잠금 유지
  - 서버에서 잠금 : 서버에서 "서버를 잠그고 모든 메소드를 호출한 후 잠금을 해제하는" 메소드를 구현한다. 클라이언트가 이 메소드를 호출한다.
  - 연결(Adpated) 서버 : 잠금을 수행하는 중간 단계를 생성한다. 

#### 동기화하는 부분을 작게 만들어라
- 자바에서 synchronized 키워드를 사용하면 락을 설정한다.
- 락은 스레드를 지연시키고 부하를 가중시키기 때문에 키워드를 남발하지 않는다.
- 임계영역 개수를 최대한 줄이는 것이 좋지만, 필요 이상의 임계영역 크기는 스레드 간의 경쟁이 늘어나고 프로그램 성능이 떨어진다.

#### 올바른 종료 코드는 구현하기 어렵다
- ex. 데드락
  - 부모 스레드가 자식 스레드를 여러 개 만들고, 모두 끝나면 자원을 해제하고 종료하는 시스템
  - 자식 스레드 하나가 데드락에 걸리면 부모 스레드는 계속 기다리게되고, 프로그램은 종료할 수 없다.

#### 스레드 코드 테스트하기
- 테스트가 정확성을 보장하지는 않지만, 위험도를 낮출 수 있다.
- 문제를 노출하는 테스트 케이스를 작성하라
- 구체적인 지침
  - 말이 안되는 실패는 잠정적인 스레드 문제로 취급하라
  - 다중 스레드를 고려하지 않은 순차 코드부터 제대로 돌게 만들자
  - 다중 스레드를 쓰는 코드 부분을 다양한 환경에 쉽게 끼워 넣을 수 있게 스레드 코드르 ㄹ구현하라
  - 다중 스레드를  쓰는 코드 부분을 상황에 맞게 조율할 수 있게 작성하라
  - 프로세서 수보다 많은 스레드를 돌려보라
  - 다른 플랫폼에서 돌려보라
  - 코드에 보조 코드를 넣어 돌려라. 강제로 실패를 일으키게 해보라
  - 직접 구현하기
  - 자동화
---
### 📌 14장 점진적인 개선
#### 점진적으로 개선하다
- 테스트 주도 개발(Test-Driven Development)
  - 언제 어느 때라도 시스템이 돌아가야 한다.
  - 내용이 변경되어도 시스템 변경 전과 똑같이 돌아가야 한다.

- 소프트웨어 설계는 분할만 잘해도 품질이 크게 높아진다.
- 관심사를 분리하면 코드를 이해하고 보수하기 훨씬 쉬워진다.
