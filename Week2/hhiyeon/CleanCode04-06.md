### 📌 4장 주석
- 주석 사용 이유 : 코드로 의도를 표현하지 못해,  실패를 만회하기 위해 사용
  - 코드는 변화하기 때문에, 주석이 점점 코드에서 분리될 수 있다. 주석을 가능한 줄이도록 노력한다.

#### 주석은 나쁜 코드를 보완하지 못한다

#### 코드로 의도를 표현하라
```java
// 직원에게 복지 혜택을 받을 자격이 있는지 검사한다.
if ((employee.flags & HOURLY_FLAG) && (employee.age > 65)){}

// 코드로 의도 표현
if (employee.isEligibleForFullBenefits())
```

#### 좋은 주석
- 법적인 주석 : 저작권 정보, 소유권 정보
- 정보를 제공하는 주석 : ex. 정규 표현식이 시각과 날짜를 뜻하는 것을 명한다.
```java
// kk:mm:ss EEE, IWI dd, yyyy 형식이다. Pattern timeMatcher = Pattern.compile(
:"*\\d W,*\\w,*\\d "*\)\;d
```
- 의도를 설명하는 주석
- 의미를 명료하게 밝히는 주석
- 결과를 경고하는 주석 : ex. 특정 케이스(여유 시간이 충분하지 않은 경우)를 꺼야 하는 이유를 설명
  - 굳이 주석을 사용하지 않아도 @Ignore 속성으로 테스트 케이스를 끌 수 있다.
- TODO 주석 : 앞으로 할 일
- 중요성을 강조하는 주석 
- 공개 API에서 Javadocs 
- 나쁜 주석 
  - 대다수 주석은 나쁜 주석
  - 주절거리는 주석
  - 같은 이야기를 중복하는 주석
  - 오해할 여지가 있는 주석
  - 의무적으로 다는 주석
  - 이력을 기록하는 주석
  - 있으나 마나 한 주석
  - 무서운 잡음
  - 함수나 변수로 표현할 수 있으면 주석을 달지 마라
  - 위치를 표현하는 주석
  - 닫는 괄호에 다는 주
  - 주석으로 처리한 코드
  - HTML 주석 : 읽기 어렵다.
  - 전역 정보 : 주석은 근처에 있는 코드만 기술
  - 너무 많은 정보
  - 모호한 관계
  - 함수 헤더
  - 비공개 코드에서 Javadocs

--- 
### 📌 5장 형식 맞추기
#### 형식을 맞추는 목적
- 코드 형식은 의사소토의 일환

#### 적절한 행 길이를 유지하라
- 대부분 200줄의 코드인 파일로도 커다란 시스템 구축이 가능하다.

#### 신문 기사처럼 작성하라
- 위에서 아래로 내려갈수록 의도를 세세하게 묘사한다.

#### 개념은 빈 행으로 분리하라
- 빈 행 : 새로운 개념을 시작하는 시각적 단서

#### 세로 밀집도
- 서로 밀집한 코드 행은 세로로 가까이 놓아야 한다.
```java
public class ReporterConfig {
/**
* 리포터 리스너의 클래스 이름
*/
private String m_className;
/**
* 리포터 리스너의 속성
*/
private List<Property> m_properties = new ArrayList<Property>(); public void addProperty(Property property) {
m_properties. add (property);
}

// 변경 후
public class ReporterConfig {
  private String m_className;
  private List<Property> m_properties = new ArrayList<Property>();
  public void addProperty(Property property) { m_properties. add(property);
  } }
```

#### 수직 거리
- 서로 밀접한 개념은 세로로 가까이 위치하도록 한다.
- 멀리 떨어져 있으면 소스 파일과 클래스를 여기저기 뒤져야하는 불편함이 생긴다.
- 변수 선언 : 변수를 사용하는 위치에 최대한 가까이 선언
- 인스턴스 변수 : 클래스 맨 처음에 선언
- 종속 함수 : 종속되는 2개의 함수는 세로로 가까이 배치한다.
  - 가능한 호출하는 함수를 호출되는 함수보다 먼저 배치한다.
- 개념의 유사성 : 개념적인 친화도가 높을수록 코드를 가까이 배치한다.
- 세로 순서 : 가장 중요한 개념을 먼저 표현한다.
- 가로 형식 맞추기 : 하나의 행의 가로 길이는 짧을수록 좋다. 최대 120자가 넘지 않도록 한다.
- 가로 공백과 밀집도 : 공백을 사용해서 밀접한 개념과 느슨한 개념을 표현한다.
- 들여쓰기 : scope(범위)를 표현하기 위해 코드를 들여쓴다.


#### 팀 규칙
- 어디에 괄호를 넣을지
- 들여쓰기는 몇 자리로 할지
- 클래스, 변수, 메서드 이름 규칙
--- 
### 📌 6장 객체와 자료구조

#### 자료 추상화
- 변수를 의존하지 않게 만들기 위해 private 사용
- get(조회), 설정(set)은 왜 public 인지?
- 변수를 private 으로 선언해도, 조회와 설정을 공개하면 구현을 외부로 노출하게 된다.
  - 구현을 감추기 위해서는 추상화 필요. 추상 인터페이스 제공

#### 자료/객체 비대칭
- 객체 : 추상화 뒤로 자료를 숨기고 자료를 다루는 함수만 공개
- 자료구조 : 자료를 그대로 공개하고 별다른 함수는 제공하지 않는다.

#### 디미터 법칙
- 모듈은 자신이 조작하는 객체의 속사정을 몰라야 한다는 법칙
- 객체는 자료를 숨기고, 함수를 공개한다.
- 기차 충돌 : 여러 함수를 이어서 호출한 것은 이어진 기차로 보여진다.
```java
final String outputDir = ctxt.getOptions().getScratchDir().getAbsolutePath();

// 기차 충돌 개선
Options opts = ctxt.getOptions();
File scratchDir = opts.getScratchDir();
final String outputDir = scratchDir.getAbsolutePath();
```
- 하지만, 위의 ctxt, Options, ScratchDir가 객체면 디미터 법칙을 위반한다.
- 아래처럼 구현하면 디미터 법칙을 거론할 필요가 없다.
```java
final String outputDir = ctxt.options.scratchDir.absolutePath;
```

#### 자료 전달 객체
- 자료 구조체, 자료 전달 객체 DTO(Data Transfer Object) : 공개 변수만 있고, 함수가 없는 클래스
- 데이터 베이스에 저장된 가공되지 않은 정보를 애플리케이션 코드에서 사용할 객체로 변환하는 일련의 단계에서 가장 처음으로 사용하는 구조체
- 빈(Bean) : 구조 좀 더 일반적인 형태
  - private 변수를 조회/설정 함수로 조작한다.
- 활성 레코드 : DTO 의 특수한 형태
  - save, find 와 같은 탐색 함수도 제공한다.
  - 데이터베이스 테이블이나 다른 소스에서 자료를 직접 변환한다.
  - 활성 레코드는 자료 구조로 취급한다.
  - 비즈니스 규칙을 담고, 내부 자료를 숨기는 객체는 따로 생선한다.

#### 결론
- 객체는 동작을 공개하고 자료를 숨긴다.
- 어떤 시스템을 구현할 때, 새로운 자료 타입을 추가하는 유연성이 필요하면 객체
- 새로운 동작을 추가하는 유연성이 필요하면 자료 구조와 절차적인 코드가 적합하다.
