# 20장 : 업무 규칙 

### Entity
: 핵심 규칙과 핵심 데이터가 결합된 객체 
- 컴퓨터 시스템 내부의 객체
- 핵심 업무 데이터를 기반으로 동작하는 일련의 핵심 업무 규칙 구체화 
- 업무 데이터를 직접 포함 / 핵심 업무 데이터 접근 가능 

엔티티 생성 시에는 핵심 업무 데이터와 핵심 업무 규칙을 하나로 묶어, 별도의 소프트웨어 모듈로 생성 

### UseCase 
- 자동화된 시스템이 사용되는 방법을 설명 
- input, output, 해당 출력을 생성하기 위한 처리 단계를 기술하는 객체
   - 어플리케이션에 특화된 업무 규칙을 구현하는 하나 이상의 함수 제공    
- application에 특화된 업무 규칙 설명 
- Entity 내부의 핵심 업무 규칙을 어떻게, 그리고 언제 호출할지 명시하는 규칙을 담고 있음 
- 사용자 인터페이스를 기술하지 X / 시스템이 사용자에게 어떻게 보이는 지 기술하지 X
-

> 엔티티 vs 유스케이스
> - 유스케이스(저수준) : 단일 어플리케이션에 특화, 해당 시스템의 입력/출력에 가깝게 유지 
> - 엔티티(고수준) : 수많은 어플리케이션에서 사용될 수 있도록 일반화되어 있음, 따라서 input/output 과는 거리가 멀다. 
> 
> 유스케이스가 엔티티에 의존하는 형태 

### Req/Res Model 
입력 데이터를 받아 유스케이스가 출력 데이터를 생성
- 유스케이스 클래스의 코드가 HTML, SQL 등 더욱 저수준을 알게해서는 안된다. 
- 의존성 제거가 중요 
- 요청 및 응답 모델은 독립적이어야함 
  - 두 객체의 목적이 다르기 때문에 언제든지 변경 가능성 존재 
  - 위반할 경우 OCP, SRP 위배 

### 결론
업무 규칙 : 
- 소프트웨어 시스템 존재 이유
- UI / DB 같은 저수준 관심사로 오염되어서는 안된다. 
- 업무 규칙과 거리가 먼 코드는 플러그인 형식이어야 한다.
- 업무 규칙은 시스템에서 독립적이며, 가장 많이 재사용될 수 있어야 함 


# 21장 : 소리치는 아키텍처 

### 아키텍처의 테마 
- 소프트웨어 아키텍처 : 시스템의 유스케이스를 지원하는 구조 (야콥슨) 
- 프레임워크는 도구일 뿐, 아키텍처가 준수해야할 대상이 아님
- 아키텍처를 프레임워크 중심적으로 만들게 되었을 때, 유스케이스가 중심이 될 수 없음 

### 아키텍처의 목적
좋은 아키텍처 : 유스케이스를 중심에 두고 있어, 프레임워크 및 도구에 구애받지 않고 유스케이스를 지원하는 구조가 자연스럽게 기술 
- 개발 환경 / 도구 결정을 미룰 수 있음 
- 지엽적인 관심사에 대해 결합 분리 가능 

> Web? 
> 웹은 전달 메커니즘일 뿐이므로 어플리케이션이 웹을 통해 전달된다는 세부사항일 뿐이다. 
> 따라서 시스템 구조를 지배해선 안된다. 
> **근본적인 아키텍처를 고치지 않아도 시스템은 다른 방법으로라도 전달될 수 있어야 함**

### 테스트하기 쉬운 아키텍처 
- 유스케이스를 최우선으로 하고, 프레임워크와 적당한 거리를 둔다. 
  - 필요한 유스케이스에 대해 단위 테스트가 가능해야함 
- 엔티티 객체는 반드시 Plain Old Object 여야한다. 
- 프레임워크, DB 등 저수준에 의존해서는 안된다. 
- 유스케이스가 엔티티 객체를 조작해야 한다. 
- 프레임워크로 인해 테스트에 어려움이 있어서는 안된다. 

### 결론 
아키텍처는 시스템을 이야기해야하며, 시스템에 적용한 프레임워크에 대해 이야기해서는 안된다. 

---

# 22장 : 클린 아키텍처

다양한 아키텍처의 공통적인 목표 : 관심사 분리 
- ex_ Hexagonal Architecture
- 계층 분리를 통한 관심사 분리 
- 각 아키텍처는 최소한 업무 규칙을 위한 계층 하나, User, System Interface를 위한 또 하나의 계층 하나를 반드시 포함

아키텍처는 시스템이 다음과 같은 특징을 띌 수 있도록 만든다. 
- 프레임워크 독립성
  - 아키텍처는 프레임워크 존재 여부에 의존하지 않기 때문에, 프레임워크를 제약사항이 아닌 도구로써 사용할 수 있도록 한다. 
- 테스트 용이성
  - 비즈니스 규칙은 UI, DB, Web Server, 기타 외부 요소 없이 테스트가 가능하다. 
- UI 독립성 
  - 시스템의 나머지 부분을 변경하지 않고도 UI를 쉽게 변경 가능하다 
- DB 독립성 
  - Oracle, MS sql 서버, MongoDB, CauchDB ... 등 다양한 DB로 교체가 가능하다. 
  - 업무 규칙은 DB와 결합되지 않는다. 
- 모든 외부 에이전시에 대한 독립성 
  - 실제 업무 규칙은 외부 세계와의 인터페이스에 대해 전혀 알지 않는다. 

### 의존성 규칙 

![image](https://user-images.githubusercontent.com/27190617/210160807-687c0244-8649-4df3-875d-e264afe4db72.png)

- 안으로 향할수록 고수준의 SW
- 바깥쪽 원 : 메커니즘 
- 안쪽 원 : 정책 

**소스 코드 의존성은 반드시 안쪽으로, 고수준의 정책을 향해야 한다.**
- 내부의 원에 속한 요소는 외부의 원에 속한 어떤 것도 알지 못함 
  - 함수,클래스, 변수, 소프트웨어 엔티티로 명명되는 모든 것을 언급해서는 안된다 
- 외부의 원에 선언된 데이터 형식도 내부의 원에서 절대로 사용해서는 안된다 

### 엔티티 
- 전사적인 핵심 업무 규칙을 캡슐화
- 전사적이지 않고 단순한 애플리케이션을 작성한다면 엔티티는 해당 애플리케이션의 업무 객체가 된다.
- 운영 관점에서 특정 애플리케이션에 무언가 변경이 필요하더라도 엔티티 계층에는 절대로 영향을 주어서는 안 된다.

### 유스케이스 
- 애플리케이션에 특화된 업무 규칙을 포함하며 모든 유스케이스를 캡슐화하고 구현한다.
- 엔티티로 들어오고 나가는 데이터 흐름을 조정
- 엔티티가 자신의 핵심 업무 규칙을 사용해서 유스케이스의 목적을 달성하도록 이끈다.
- 이 계층에서 발생한 변경이 엔티티에 영향을 주면 안 되며, 외부 요소에서 발생한 변경이 이 계층에 영향을 주면 안된다.
  - 관심사로부터 격리되어있다.
  - 하지만 운영 관점: 애플리케이션이 변경된다면 유스케이스가 영향을 받고, 따라서 이 계층의 소프트웨어에도 영향을 줄 것

### 인터페이스 어댑터 
- 일련의 어댑터들로 구성 
- 어댑터는 데이터를 유스케이스와 엔티티에게 가장 편리한 형식에서 데이터베이스나 웹 같은 외부 에이전시에게 가장 편리한 형식으로 변환
- 데이터를 엔티티와 유스케이스에게 가장 편리한 형식에서 영속성용으로 사용 중인 임의의 프레임워크가 이용하기에 가장 편리한 방식으로 변환
- 데이터를 외부 서비스와 같은 외부적인 형식에서 유스케이스나 엔티티에서 사용되는 내부적은 형식으로 변환하는 또 다른 어댑터 필요

### 프레임워크와 드라이버 
- 데이터베이스나 웹 프레임워크 같은 프레임워크나 도구들로 구성
- 일반적으로 이 계층에는 안쪽원과 통신하기 위한 코드 외에 특별히 작성할 코드가 많지 않다.
- 세부사항이 위치하는 곳
- 외부에 위치시켜 피해를 최소화

### 원의 개수 
원은 꼭 네 개여야 할까? 
- 그럴필요는 없지만 항상 의존성 규칙은 적용된다.
- 소스코드 의존성은 안쪽을 향한다.
  - 안쪽으로 갈수록 추상화와 정책의 수준은 높아진다.
  - 가장 바깥쪽 원은 저수준의 구체적인 세부사항으로 구성된다.
  - 가장 안쪽 원은 가장 범용적이며 높은 수준

### 계층별 경계 횡단 
제어흐름과 의존성의 방향이 명백히 반대여야 하는 경우, 보통 **의존성 역전 원칙**을 사용하여 해결
- 동적 다형성을 이용하여 소스 코드 의존성을 제어흐름과 반대로 만들 수 있고, 이를 통해 제어흐름이 어느 방향으로 흐르든 상관 없이 의존성 규칙을 준수할 수 있다.
- 경계를 가로지르는 데이터는 흔히 간단한 데이터 구조로 이루어져 있다.
- 격리되어 있는 간단한 데이터 구조가 경계를 가로질러 전달된다는 사실
- 데이터 구조가 어떤 의존성을 가져 의존성 규칙을 위배하게 되는 일은 바라지 않는다.
- 따라서 경계를 가로질러 데이터를 전달할 때, 데이터는 항상 내부의 원에서 사용하기에 가장 편리한 형태를 가져야만 한다.

![image](https://user-images.githubusercontent.com/27190617/210160898-3d594e65-d7e5-404c-ba1d-2d0d2754e8d9.png)

### 결론 
SW를 계층으로 분리하고 의존성 규칙을 준수한다면 본질적으로 테스트하기 쉬운 시스템을 만들게 되며, 
시스템의 외부 요소가 레거시더라도 쉽게 교체할 수 있다. 
