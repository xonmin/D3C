# 20장 : 업무 규칙 

### Entity
: 핵심 규칙과 핵심 데이터가 결합된 객체 
- 컴퓨터 시스템 내부의 객체
- 핵심 업무 데이터를 기반으로 동작하는 일련의 핵심 업무 규칙 구체화 
- 업무 데이터를 직접 포함 / 핵심 업무 데이터 접근 가능 

엔티티 생성 시에는 핵심 업무 데이터와 핵심 업무 규칙을 하나로 묶어, 별도의 소프트웨어 모듈로 생성 

### UseCase 
- 자동화된 시스템이 사용되는 방법을 설명 
- input, output, 해당 출력을 생성하기 위한 처리 단계를 기술하는 객체
  - 어플리케이션에 특화된 업무 규칙을 구현하는 하나 이상의 함수 제공    
- application에 특화된 업무 규칙 설명 
- Entity 내부의 핵심 업무 규칙을 어떻게, 그리고 언제 호출할지 명시하는 규칙을 담고 있음 
- 사용자 인터페이스를 기술하지 X / 시스템이 사용자에게 어떻게 보이는 지 기술하지 X
-

> 엔티티 vs 유스케이스
> - 유스케이스(저수준) : 단일 어플리케이션에 특화, 해당 시스템의 입력/출력에 가깝게 유지 
> - 엔티티(고수준) : 수많은 어플리케이션에서 사용될 수 있도록 일반화되어 있음, 따라서 input/output 과는 거리가 멀다. 
> 
> 유스케이스가 엔티티에 의존하는 형태 

### Req/Res Model 
입력 데이터를 받아 유스케이스가 출력 데이터를 생성
- 유스케이스 클래스의 코드가 HTML, SQL 등 더욱 저수준을 알게해서는 안된다. 
- 의존성 제거가 중요 
- 요청 및 응답 모델은 독립적이어야함 
  - 두 객체의 목적이 다르기 때문에 언제든지 변경 가능성 존재 
  - 위반할 경우 OCP, SRP 위배 

### 결론
업무 규칙 : 
- 소프트웨어 시스템 존재 이유
- UI / DB 같은 저수준 관심사로 오염되어서는 안된다. 
- 업무 규칙과 거리가 먼 코드는 플러그인 형식이어야 한다.
- 업무 규칙은 시스템에서 독립적이며, 가장 많이 재사용될 수 있어야 함 


# 21장 : 소리치는 아키텍처 

### 아키텍처의 테마 
- 소프트웨어 아키텍처 : 시스템의 유스케이스를 지원하는 구조 (야콥슨) 
- 프레임워크는 도구일 뿐, 아키텍처가 준수해야할 대상이 아님
- 아키텍처를 프레임워크 중심적으로 만들게 되었을 때, 유스케이스가 중심이 될 수 없음 

### 아키텍처의 목적
좋은 아키텍처 : 유스케이스를 중심에 두고 있어, 프레임워크 및 도구에 구애받지 않고 유스케이스를 지원하는 구조가 자연스럽게 기술 
- 개발 환경 / 도구 결정을 미룰 수 있음 
- 지엽적인 관심사에 대해 결합 분리 가능 

> Web? 
> 웹은 전달 메커니즘일 뿐이므로 어플리케이션이 웹을 통해 전달된다는 세부사항일 뿐이다. 
> 따라서 시스템 구조를 지배해선 안된다. 
> **근본적인 아키텍처를 고치지 않아도 시스템은 다른 방법으로라도 전달될 수 있어야 함**

### 테스트하기 쉬운 아키텍처 
- 유스케이스를 최우선으로 하고, 프레임워크와 적당한 거리를 둔다. 
 - 필요한 유스케이스에 대해 단위 테스트가 가능해야함 
- 엔티티 객체는 반드시 Plain Old Object 여야한다. 
- 프레임워크, DB 등 저수준에 의존해서는 안된다. 
- 유스케이스가 엔티티 객체를 조작해야 한다. 
- 프레임워크로 인해 테스트에 어려움이 있어서는 안된다. 

### 결론 
아키텍처는 시스템을 이야기해야하며, 시스템에 적용한 프레임워크에 대해 이야기해서는 안된다. 
