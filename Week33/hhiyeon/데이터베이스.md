### 데이터베이스
- 데이터베이스를 사용하기 전까지는 파일 시스템을 이용해서 데이터를 관리
- 파일 시스템 : 파일(데이터의 모임)을 저장 장치에 저장하고 사용하기 위한 일종의 규칙이나 체계
- 파일 시스템의 단점 : 데이터간 불일치, 동시성 제어 제공X, 회복 기능 X, 데이터 독립성과 무결성 X, 데이터 모델링 개념이 부족
- 데이터 종속성, 데이터 중복성, 데이터 무결성 문제를 해결하기 위해 데이터 베이스 사용


---
#### 데이터베이스 특징
1. 무결성
   - 여러 경로를 통해 잘못된 데이터가 발생하는 경우를 방지
   - 데이터의 오류 X, constraints(제약 조건) 사용


2. 독립성
   - DB 물리적 크기, 위치 변경에도 SW에 영향을 끼치지 않는다. 


3. 보안성
   - 인가된 사용자만 DB 접근 허용해서 데이터 보호, 계정 관리, 권한 설정 


4. 중복 최소화
   - 데이터베이스의 데이터를 통합해서 관리해서 자료 중복, 데이터 종속성 해결 


5. 일관성
   - 하나의 데이터를 변경했을 때, 발생할 수 있는 데이터의 불일치성 배제


---
#### Index(인덱스)
- 추가적인 쓰기 작업과 저장 공간을 활용하여 데이터베이스 테이블의 검색 속도를 향상시키기 위한 자료구조
- 테이블의 칼럼과 해당 레코드가 저장된 주소를 key-value 쌍으로 인덱스를 만들어 둔다.
- DBMS 인덱스는 값 탐색(SELECT)은 빠르지만, 값의 삭제, 추가, 수정(Update, Delete, Insert)의 경우에는 쿼리문 실행 속도가 느려진다.


#### Index 자료구조
- B+-Tree 인덱스 알고리즘
  - 일반적으로 사용되는 인덱스 알고리즘
  - 칼럼의 값을 변형하지 않고, 원래의 값을 이용해 인덱스하는 알고리즘
- Hash 인덱스 알고리즘
  - 칼럼의 값으로 해시 값을 계산해서 인덱싱하는 알고리즘
  - 주로 메모리 기반의 데이터 베이스에서 사용
- B+-Tree 를 사용하는 이유는?
  - SELECT query에 부등호(<>) 연산도 포함되기 때문에 hash table에서 사용하기 적합하지 않다.


---
#### Primary index(기본 인덱스), Secondary index(보조 인덱스)
- 클러스터(Cluster) : 여러 개를 하나로 묶는 의미
- 클러스터드 인덱스
  - 인덱스에서 비슷한 것을 묶어서 저장하는 형태
  - 클러스터드 인덱스는 테이블의 primary key에만 적용
  - primary key 값이 비슷한 레코드끼리 묶어서 저장하는 것
  - 테이블 당 한 개만 생성 가능하다. <-> 논 클러스터드 인덱스는 테이블 당 여러개 생성 가능


#### 테이블 생성 시 파일 구성
- FRM : 테이블 구조 저장 파일
- MYD : 실제 데이터 파일
- MYI : Index 정보 파일(Index 사용시 생성)
  - 쿼리로 index를 사용하는 칼럼을 검색하면, MYI 파일의 내용을 활용


#### 인덱스 단점
- index를 생성하면, .mdb 파일 크기가 증가한다.
- 한 페이지를 동시에 수정할 수 있는 병행성 감소
- 데이터 변경이 자주 일어날 경우 index의 재작성으로 성능 저하


#### 인덱스 활용 예시
- 사용하면 좋은 경우
  - where 절에서 자주 사용되는 경우
  - 외래키가 사용되는 경우
  - join 에 자주 사용되는 경우
- Index 사용하면 안좋은 경우
  - Data 중복도가 높을 경우
  - DML이 자주 일어나는 경우(Insert, Delete, Update)

#### DML 요청 시 상황
- INSERT
  - 기존 block에 여유가 없으면 새로운 data 입력
  - 새로운 block을 할당 받고, Key를 옮긴다.
  - index split 작업 동안, 해당 block의 key 값에 대해 DML 블로킹
- DELETE
  - table에서 data 삭제 : data는 지워지고, 다른 Data가 공간 사용 가능
  - index에서 data 삭제 : data가 지워지지 않고, 사용 안됨으로 표시된다.
- UPDATE
  - table에서 update : index는 update 불가능
  - index에서 update : delete 발생 후, 새로운 작업 insert (table보다 2배 작업)


---
#### 정규화(Normalization)
- 데이터의 중복을 줄이고, 무결성 향상, 이상 현상을 방지한다.

- 이상 현상(Anomaly)
  - 잘못된 정규화로 데이터의 중복이 발생되고, 무결성이 저하되는 현상
- 삽입 이상(Insertion Anomaly)
  - 기본키가 {Studnet ID, Course ID} 일 때, Course를 수강하지 않은 학생은 Course ID가 없음.
  - 기본키는 Null이 될 수 없어서 테이블에 추가 불가능
- 갱신 이상(Update Anomaly)
  - 어떤 학생의 전공이 A에서 B로 바뀌는 경우, 모든 A를 B로 바꿔야 한다. 하지만 일부가 바뀌지 않는 형상
- 삭제 이상(Deletion Anomaly)
  - 어떤 학생이 수강을 삭제할 때, {Student ID, Department, Course ID, Grade} 정보 중에 Student ID, Department와 같은 학생에 대한 정보도 삭제 된다.


---
#### 제1 정규화(1NF)
- 테이블 칼럼이 원자값(하나의 값)을 갖도록 테이블을 분리시키는 것
- 릴레이션에 속한 모든 도메인이 원자값으로만 되어 있어야한다.
- 모든 속성에 반복되는 그룹이 나타나지 않는다.
- 기본키를 사용하여 관련 데이터의 각 집합을 고유하게 식별 가능해야 한다.

#### 제2 정규화(2NF)
- 제 1정규화를 만족하고, 테이블의 모든 칼럼이 완전 함수적 종속을 만족해야 한다.
- 기본키가 복합키(키1, 키2) 일 때, 두개의 키 중 하나의 키만 남긴다.

#### 제3 정규화(3NF)
- 제 2정규화를 만족하고, 진행된 테이블에서 이행적 종속을 없애기 위해 테이블을 분리한다.
- A -> B, B -> C 이면 = A -> C

#### 정규화의 장점과 단점
- 장점
  - 데이터베이스를 변경 할 때, 이상 현상을 방지할 수 있다.
  - 데이터베이스를 확장할 때, 정규화 데이터베이스는 일부만 변경해도 된다.
- 단점
  - 릴레이션의 분해로 인해, 릴레이션 간의 연산(JOIN)이 증가하게 된다. -> 응답 시간 저하
  - 과도한 정규화와 데이터 입력/수정/삭제 연산이 잦으면, 데이터 처리 속도가 느려저 응답 시간 저하 or 데이터 무결성 X

#### 반정규화
- SQL에서 잦은 조인으로 성능 저하가 나타나는 경우에 반정규화 사용
- 자주 사용되는 테이블에 접근하는 프로세스 수가 많고, 항상 일정한 범위만 조회하는 경우 사용
- 테이블에 대량 데이터가 있고 대량의 범위를 자주 처리하는 경우
- 테이블에 지나친 조인으로 데이터 조회가 어려울 경우


---