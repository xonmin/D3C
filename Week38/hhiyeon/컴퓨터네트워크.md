### 컴퓨터 네트워크 
#### 동기(Synchronous) VS 비동기(Asynchronous)
- 동기 : 함수A가 함수B의 작업 완료 후 리턴을 기다리거나, 작업의 완료(리턴)를 계속해서 확인하는 작업 흐름
- 비동기 : 함수 A가 함수 B를 호출할 때 콜백 함수를 함께 전달하여 함수 B의 작업이 완료되면 함께 보낸 함수를 실행
  - 이전에 호출한 함수의 작업 완료 여부를 신경쓰지 않는 상황
  - call back이 오기 전까지 신경쓰지 않고 다른 일을 할 수 있다.
- 호출되는 함수의 작업 완료 여부를 신경쓰냐, 함수 실행/리턴 순차적인 흐름을 따르는가



#### 블로킹(blocking) vs 논블로킹(non-blocking)
- 블로킹
  - A 함수가 B를 호출하면 제어권을 B 함수에게 넘겨짐
  - A에겐 제어권이 없기 떄문에 실행을 멈춤
  - B함수 실행이 끝나면 제어권을 다시 A가 받아서 실행
- 논블로킹
  - A함수가 B함수를 호출해도 본인 행동의 제어권을 본인(A)이 가지고 있음
  - B 함수가 실행되지만 A는 B를 호출한 이후에도 자신의 코드를 계속 실행할 수 있다.


#### 4가지의 조합적 동작의 차이
- Sync - Blocking
  - 함수 A는 함수 B의 리턴값을 필요로한다. (동기)
  - 제어권을 함수 B 에게 제어권을 넘겨준다. (블로킹)
  - 함수 B가 실행을 완료하여 리턴값과 제어권을 돌려줄 때까지 기다린다.
- Sync - NonBlocking
  - A 함수는 B 함수를 호출한다.
  - 이 때 A 함수는 B 함수에게 제어권을 주지 않고 본인의 코드를 계속 실행한다 (논블로킹)
  - 하지만 A 함수는 B 함수의 리턴값이 필요하기 때문에, 계속 B 함수에게 함수 실행을 완료했는지 물어본다 (동기)
  - 대기 시간동안 다른 일 수행 가능
- Async - Nonblocking
  - A 함수는 B 함수를 호출한다.
  - 이 때 제어권을 A는 계속 가지고 있어서 B 함수를 호출한 이후에도 멈추지 않고 자신의 코드를 계속 실행 (논블로킹)
  - B 함수를 호출할 때 콜백 함수를 같이 넘겨서 B 함수가 작업이 끝나면 콜백함수 실행을 통해 리턴 전달 (비동기)
- Async - Blocking
  - A 함수는 B 함수를 호출
  - 제어권을 함수 B 에게 제어권을 넘겨준다. 제어권을 받기 전까지 기다린다. (블로킹)
  - B 함수를 호출할 때 콜백함수를 같이 넘겨서 B 함수가 작업이 끝나면 콜백함수 실행을 통해 리턴 전달 (비동기)

---
#### OSI 7 계층

1. 물리(physical)
- 리피터, 케이블, 허브
- 전기적인 신호로 변환해서 주고받는 기능을 진행하는 공간
- 데이터의 전송

2. 데이터 링크(Data link)
- 브릿지, 스위치
- 물리 계층으로 송수신되는 정보를 관리해서 안전하게 전달되도록 도와주는 역할
- MAC 주소로 통신
- 흐름제어, 에러검출, 재전송

3. 네트워크(Network)
- 라우터, IP
- 데이터를 목적지까지 가장 안전하고 빠르게 전달하는 기능 담당
- 라우터를 통해 이동할 경로를 선택하여 IP 주소를 지정하고, 해당 경로에 따라 패킷 전달
- 라우팅, 흐름제어, 오류제어, 세그멘테이션

4. 전송(Transport)
- TCP, UDP
- 프로토콜을 통해 통신 활성화. 프로그램들이 전송을 할 수 있도록 제공
- TCP : 신뢰성, 연결지향적
- UDP : 비신뢰성, 비연결성, 실시간

5. 세션(Session)
- API, Socket
- 데이터가 통신하기 위한 논리적 연결 담당

6. 표현(Presentation)
- JPEG, MPEG
- 데이터 표현에 대한 독립성을 제공하고 암호화하는 역할
- 파일 인코딩, 명령어 포장, 압축, 암호하ㅗ

7. 응용(Application)
- HTTP, FTP, DNS
- 응용 프로세스와 직접 관계하여 일반적인 응용 서비스를 수행
- 사용자 인터페이스, 전자우편, 데이터베이스 관리 등의 서비스 제공

---
#### TCP와 UDP
- TCP(Transmission Control Protocol)
  - 신뢰성 있는 바이트 스트림 전송
  - 송신자와 수신자가 소켓이라고 부르는 종단점을 생성한다.
  - 3-way handshake 으로 연결 설정
  - 전이중(full-duplex), 점대점(point to point) 방식
  - 멀티캐스팅, 브로드캐스팅을 지원하지 않는다.
- UDP(User Datagram Protocol)
  - 비연결형 프로토콜
  - 흐름제어, 오류제어 또는 손상된 세그먼트의 수신에 대해 재전송 X
---
#### GET과 POST
- GET
  - HTTP Request Message의 Header에 URL이 담겨서 전송
  - query string : ? 뒤에 데이터가 붙어 request
  - 제한적인 크기
  - URL에 데이터가 노출된다.
- POST
  - HTTP Request Message의 Body에 데이터가 담겨서 전송
  - 보안이 필요한 데이터는 POST가 더 낫다. -> 패킷 스니핑 위험으로 완전하지는 않다.
---
#### HTTP(HyperText Transfer Protocol)
- HTTP -> TCP
- 인터넷에서 클라이언트와 웹 서버가 자원을 주고 받을 때 사용하는 통신 규약
- HTTP 1.1 : connection 당 하나의 요청 처리 -> 동시 전송의 문제
- HTTP 2.0 : 서버로부터 여러 파일을 병렬적으로 전송하기 때문에, 속도 개선이 가능하다.
- 클라이언트 요청과 서버의 응답에 필수 적인 정보인 ‘헤더’
  - 데이터 중복 전송을 방지
  - 데이터를 압축해서 전송하기 때문에 서버와의 통신으로 인해 발생하는 전송 트래픽을 절감할 수 있다.
- 필요한 리소스를 클라이언트가 요청하기 전에 서버에서 먼저 전송할 수 있는 ‘서버푸시’ 기능도 새롭게 도입되어서 불필요한 통신 과정을 없앴다.
- REST API는 HTTP 통신으로 이루어진다.
- 단점
  - 통신 상대를 확인하지 않아서 모르는 사람에게서도 요청이 오면 무조건 응답을 한다.
  - 이를 보완하기 위해서 SSL 사용 -> SSL은 증명서를 이용해서 상대를 확인할 수 있다.

----
#### HTTPS(HyperText Transfer Protocol Secure)
- HTTPS -> SSL -> TCP
- 인터넷에서 정보를 암호화하는 SSL 프로토콜을 사용해서 클라이언트와 서버가 자원을 주고 받을 때 쓰는 통신 규악
  - SSL(Secure Socket Layer) or TLS(Transport Layer Security)
  - 암호화되지 않은 HTTP, 암호회된 HTTPS

- 텍스트를 공개키 암호화 방식으로 암호화한다.
- 통신 흐름
  - A 기업은 HTTPS을 적용하기 위해 공개키, 개인키 생성
  - 신뢰할 수 있는 CA 기업 선택 후, 공개키 관리를 부탁한다. (CA : Certifiacte Authority)
  - CA 기업은 공개키, 공개키 암호화 방법을 담은 인증서를 만들고, 인증서로 CA 기업의 개인키로 암호화해서 A 서버에게 제공
  - A 서버는 암호화된 인증서를 갖게된다. A 서버는 공개키로 암호화된 요청이 오면, 암호화된 인증서를 클라이언트에게 준다.
  - CA 기업의 공개키는 브라우저가 이미 알고 있기 때문에 브라우저는 암호화된 인증서를 해독하고 A 서버의 공개키를 얻게 된다.
  - A 서버와 통신할 때 얻은 A 서버의 공개키로 암호화해서 요청이 가능해진다.

----
#### 대칭키(Symmetric Key)
- 암호화와 복호화에 같은 암호키(대칭키)를 사용하는 알고리즘
- 키를 하나만 사용하기 때문에 빠르다.
- 하지만 해킹 위험이 있다.

#### 공개키(Public Key), 비대칭키(Asymmetric Key)
- 대칭키 키 분배 문제를 해결하기 위해 생긴 개념
- 고유 암호키(비밀키)를 사용해서 복호화할 수 있는 암호키(공개키)를 공개해서 사용

#### SSL - 대칭키 + 공개키 암호화 방식
- A가 웹 상에 공개된 B의 공개키로 암호화 통신에 사용할 대칭키를 암호화해서 B에게 보낸다.
- B는 자신의 비밀키로 복호화 한다.
- B는 A로부터 얻은 대칭키로 A에게 보낼 평문을 암호화해서 A에게 보낸다.
- A는 자신의 대칭키로 암호문을 복호화한다.
---
