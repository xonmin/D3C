
# 10. 애노테이션과 리플랙션 

- 애노테이션 : library가 요구하는 의미를 클래스에게 부여 가능
- 리플랙션 : 실행 시점에 컴파일러 내부 구조 분석 가능 

## 10.1 애노테이션 선언과 적용 
메타데이터를 선언에 추가시, 애노테이션을 처리하는 도구가 컴파일 시점과 실행 시점에 적절한 처리 진행 

### 10.1.1 애노테이션 적용 
코틀린에서는 `replaceWith` 파라미터를 통해 옛버전을 대신할 수 있는 패턴 제시 가능 
```kotlin 
@Deprecated("Use removeAt(index) instead.", ReplaceWith("removeAt(index)"))
fun remove(index: Int) { ... }
```
이를 통해 새로운 API 버전에 맞는 코드로 바꿔주는 퀵 픽스 제시 가능 

애노테이션 인자 가능한 것들
- primitive, String, Enum, 클래스 참조, 다른 Annotation class, 앞의 것들의 배열  

코틀린 애노테이션 인자 지정 문법 
- 클래스를 애노태이션 인자로 지정 시 `@MyAnnotation(MyClass::class)`
- 다른 애노테이션 인자로 지정 시, 인자로 들어가는 애노테이션 앞에 `@`를 넣어선 안된다. 
- 배열을 인자로 지정시, `@RequestMapping(path=arrayOf("/foo","/bar"))` 와 같이 `arrayOf()` 사용 
  - 자바에서 선언한 애노테이션 클래스를 사용한다면, value 라는 이름의 파라미터가 필요에 따라 자동으로 가변 길이 인자로 변환 (이때는 arrayOf 사용 x) 

애노테이션 인자를 컴파일 시점에 알 수 있어야 하므로, 프로퍼티를 인자로 사용하려면 `const` 변경자 사용 
```kotlin
const val TEST_TIMEOUT = 1000L 

@Test(timeout= TEST_TIMEOUT) fun testmethod() { ... }
```


### 10.1.2 애노테이션 대상

코틀린 프로퍼티는 기본적으로 자바 필드와 getter 선언과 대응 
- 주 생성자에서 프로퍼티 선언시, 이런 접근자 메소드와 파라미터 외에 자바 생성자 파라미터와도 대응된다. 
- 따라서 애노테이션을 붙일 때 이런 요소 중 어떤 요소에 애노테이션을 붙일지 표시할 필요가 있음 

**사용 지점 대상(use-sitre target)** 선언으로 애노테이션 붙일 요소 정하기 
- 사용 지점 대상은 `@`기호와 애노테이션 이름 사이에 붙으며, 이름과는 : 을 통해 분리 된다. 
```kotlin
@get : Rule 
사용지점대상 : 애노테이션이름

class HasTempFolder {
  @get:Rule 
  val folder = TemporarayFolder()
  ...
}
``` 
여기서 folder 프로터티 앞에 @Rule 을 붙이면, `@Rule 'folder' must be public` 라는 에러가 발생하는데, 해당 어노테이션은 필드에 적용되지만, 
코틀린의 필드는 기본적으로 비공기이기 때문에 예외 발생 따라서 `@get:Rule`사용해야함 
- 자바에 선언된 애노테이션을 사용해 프로퍼티에 애노테이션을 붙이는 경우, 기본적으로 프로퍼티의 필드에 그 애노테이션이 붙는다. 
- 하지만 코틀린으로 애노테이션 선언시 프로퍼티에 직접 적요할 수 있는 애노테이션 생성 가능 

사용 지점 대상을 지정할 때 지원하는 대상 목록은 다음과 같다. 
- property : 프로퍼티 전체 (자바에서 선언된 애노테이션에는 사용 불가) 
- field : 프로퍼티에 생성되는 필드 
- get / set 
- reciever : 확장함수나 프로퍼티의 수신 객체 파라미터
- param : 생성자 파라미터 
- setparam : 세터 파라미터 
- delegate : 위임 프로퍼티의 위임 인스턴스를 담아둔 필드
- file : 파일 안에 선언된 최상위 함수와 프로퍼티를 담아두는 클래스 
- 
