# 12장 컴포넌트 

컴포넌트 : 시스템의 구성 요소로 배포할 수 있는 가장 작은 단위 
- 컴파일러형 언어 : 바이너리 파일의 결합체
- 인터프리터형 언어 : 소스 파일의 결합체

> ex) java - .jar , ruby - .gem , .net -> .dll 

컴포넌트가 마지막으로 어떤 형태로 배포되든, 잘 설계된 컴포넌트라면 반드시 독립적으로 배포가 가능해야 하며 독립적으로 개발 가능한 능력을 갖춰야 한다.

### 컴포넌트의 간략한 역사 
- 소프트웨어 개발 초창기 : 프로그램이 로드될 주소 직접 제어 
- 구시대의 라이브러리 함수 접근 : 라이브러리 함수의 소스 코드를 application 코드에 직접 포함시켜 단일 프로그램으로 컴파일 
  - 이 때문에, 컴파일 과정 오래 걸리고, 메모리는 한정적
- 컴파일 시간 단축을 위해 함수 라이브러리를 개별적 컴파일 
- 라이브러리 사용 방식 : 라이브러리 로드하고 메모리 주소에 접근 방식

### 재배치성 
위에서 언급한 기존 라이브러리 사용 방식은 지속 가능하지 않았다. 

해결책 : 재배치가 가능한 binary 사용 
- 지능적인 로더를 통해 메모리에 재배치할 수 있는 형태의 바이너리를 생성하도록 컴파일러 수정 

- **외부 참조(external reference) 생성** : 프로그램이 라이브러리 호출 시, 컴파일러는 라이브러리 함수 이름  
- **외부 정의(external definition) 생성** : 라이브러리 함수를 젖ㅇ의하는 프로그램에 대해 컴파일러가 정하는 해당 이름 
  - 이를 통해 외부 정의를 로드할 위치가 정해지면, 로더가 외부 참조를 외부 정의에 링크 가능 
  - 이는 **링킹 로더(linking loader)**의 탄생 

### 링커 

링킹 로더(linking loader)의 등장으로 프로그램을 개별적 컴파일 / 로드 단위로 분할할 수 있게 되었다.
- 이후 프로그램은 점점 크기가 커졌고, 이 때문에 링킹 로더의 속도가 느려짐 
- 따라서 로드와 링크를 분리 

**링커** 
느린 부분의 링크 과정이 완료된 재배치 코드를 만듦 
- 이를 통해 로더의로딩 과정이 빠랄짐 

이후 무어(Moore)의 등장으로 메모리 저렴 / 디스크 작아짐 
- 이를 통해 다시 로드와 링크를 동시에 가능해짐 
- 다수의 `.jar` 파일 or 공유 라이브러리 링크 후, 실행 가능 

> 컴포넌트 플러그인 아키텍처(component plugin architecture)의 탄생 


--- 

# 13장 컴포넌트 응집도

### 컴포넌트 응집도의 세가지 원칙 
- REP: 재사용/릴리스 등가 원칙(Reuse/Release Equivalence Principle)
- CCP: 공통 폐쇄 원칙(Common Closure Principle)
- CRP: 공통 재사용 원칙(Common Reuse Principle)

### REP (재사용/릴리즈 등가 원칙)
> 재사용 단위는 릴리스 단위와 같다

- SW 설계와 아키텍쳐 관점에서 보면, **단일 컴포넌트는 응집성 높은 클래스와 모듈들로 구성**되어야 함 
- 컴포넌트를 구성하는 모든 모듈은 서로 공유하는 중요한 테마나 목적이 있어야 한다.
  하나의 컴포넌트로 묶인 클래스와 모듈은 버전 번호가 같고, 동일한 릴리스로 추적 관리어야한다. 
- REP를 어길 시, SW(모듈)은 `이치에 맞지`않게 된다. 

### CCP (공통 폐쇄 원칙)
> 동일한 이유로 동일한 시점에 변경되는 클래스를 같은 컴포넌트로 묶어야 한다. 
> 서로 다른 시점에 다른 이유로 변경되는 클래스는 다른 컴포넌트로 분리하라 

- 컴포넌트 관점의 SRP(단일 책임 원칙)
- 단일 컴포넌트는 변경의 이유가 여러 개여서는 안된다. 
- 대다수의 application에서 유지보수성은 재사용성보다 훨씬 중요 
- CCP는 변경될 가능성이 있는 클래스는 모두 한 곳으로 묶기를 권장 

> SRP와의 유사성
> - SRP → 서로 다른 이유로 변경되는 메서드를 서로 다른 클래스로 분리하라
> - CCP → 서로 다른 이유로 변경되는 클래스를 서로 다른 컴포넌트로 분리하라

### CRP (공통 재사용 원칙)
> 컴포넌트 사용자들을 필요하지 않는 것에 의존하게 강요하지 말라.

- 같이 재사용되는 클래스와 모듈들은 같은 컴포넌트에 포함되어야 한다. 
- 어떤 컴포넌트가 다른 컴포넌트를 사용하면, 두 컴포넌트 사이에는 의존성 생성 
- 의존하는 컴포넌트가 있다면 해당 컴포넌트의 모든 클래스에 대해 희존성을 확실히 인지해야 함 
- 강하게 결합되지 않은 클래스들은 동일한 컴포넌트에 위치시켜서는 안된다. 
- 어떤 클래스를 한 곳에 묶기보다는, **한 곳에 묶어서는 안되는 것**에 대해 피력

> ISP와의 유사성 
> - ISP → 사용하지 않는 메서드가 있는 클래스에 의존하지 말라고 조언
> - CRP → 사용하지 않는 클래스를 가진 컴포넌트에 의존하지 말라고 조언
> 
> 즉, 필요하지 않은 것에 의존하지 말라.

### 컴포넌트 응집도 균형 다이어그램 
- `REP, CCP` : inclusive 원칙 (컴포넌트를 크게)
- `CRP` : exclusive 원칙 (컴포넌트를 작게)
![img.png](img.png)

- 프로젝트의 컴포넌트 구조는 시간과 성숙도에 따라 변한다.
- 프로젝트가 실제로 수행하는 일 자체보다는 프로젝트가 발전되고 사용되는 방법과 더 관련이 깊다.

### 결론 
- 컴포넌트로 만들지 결정할 때, 재사용성과 개발가능성에 상충성을 고려할 것
- 균형을 맞추어 잡아야하는데, 이 균형점은 거의 항상 유동적 
- 결과적으로 시간이 흐름에 따라 프로젝트의 초점이 개발 가능성 -> 재사용성 
  - 그에 따라 컴포넌트를 구성하는 방식도 진화 

---

# 14장 컴포넌트 결합 