

### 9.3.1.19 해시 조인(8.0.18~)
- nested loop join 보다 빠를것으로 기대하지만 늘 그런것은 아님
  - 해시 조인은 첫 번째 레코드를 찾는 데에는 더 오래 걸리지만 총 시간은 빠름
  - best throughput(eg. mb/s) 전략에 적합 (분석과 같은 서비스)
- nested loop join 은 best-response-time 전략에 적합 (웹서비스는 온라인 trx 서비스이기에 더 유용)
- nested loop join의 차선책
  - eg. 조인 조건의 칼럼의 인덱스가 없을 때, 조인 대상 테이블의 레코드 건수가 적을 때
- join_buffer_size가 넘어가는 테이블을 조인할 때, 디스크 i/o가 많이 발생 해 해시 조인을 사용하도록 유도 되고 있음 (8.0.18~)
  - equal join 에서는 해시 조인 사용
  - anti join, semi join 에서는 nested loop join 사용 했지만, 전부 해시 조인으로 유도 (8.0.20~)
- 해시 조인은 build-phase, probe-phase 단계로 나뉨
  - build-phase: 조인 대상 테이블 중 레코드 건수가 적어, 해시 테이블로 만들기 용이한 테이블을 골라 메모리에 해시 테이블을 생성
    - 빌드 테이블: build-phase에서 해시 테이블을 만들 때 사용되는 원본 테이블
  - probe-phase: 나머지 테이블의 레코드를 읽어 해시 테이블을 일치 레코드를 찾는 과정
    - 프로브 테이블: 이때 읽는 나머지 테이블
  - `EXPLAIN FORMAT=TREE` 로 보면 쉽게 어떤게 빌드, 프로브 테이블로 사용하는지 볼 수 있음
- 조인 버퍼를 사용하며, 조인버퍼 크기를 넘어가는 테이블을 해시할땐 빌드 테이블과 프로브 테이블을 `청크` 단위로 쪼개어 연산 뒤 합침
  - 청크끼리 pair 되어있어 조인에 무리 없음
- 메모리에서 한번에 전부 가능한경우 classic hash join 알고리즘, 메모리 보다 클 경우 grace hash join 알고리즘을 hybrid하게 사용
- hash key 생성 시 xxHash64 해시 함수를 사용

### 9.3.1.20 인덱스 정렬 선호
- `group by`, `order by`를 인덱스를 사용해 처리 가능한 경우 실행 계획에서 해당 인덱스의 가중치를 높이 설정해서 실행 됨
  - 이때, 옵티마이저의 실수로 조건절을 실행한 뒤 해당 값으로 위 구문을 사용하는게 이득인 경우가 있음 (eg. order by를 했는데 row가 너무 많아 pk따라 풀스캔 되는 경우)
  - 이때 해당 인덱스를 타지 못하도록 직접 힌트(`IGNORE INDEX`)를 사용하여 처리했음(~8.0.20)
  - MySQL 서버 옵티마이저가 ORDER BY절에 너무 가중치를 부여하지 않도록 `perfer_order_index=ON/OFF` 옵티마이저 옵션이 추가됨(8.0.21~)

## 9.3.2 조인 최적화 알고리즘
테이블 개수가 많아지면 최적화된 실행 계획을 찾는것이 어려워짐
하나의 쿼리에서 조인되는 테이블의 개수가 많아지면 실행 계획을 수립하는데만 엄청난 시간이 걸릴 수도 있음
- 이를 위해 MySQL에는 `조인 쿼리의 실행 계획 최적화`를 위한 알고리즘이 2개 있음

### 9.3.2.1 Exhaustive 검색 알고리즘 (~5.0)
- from 절에 명시된 모든 테이블의 조합에 대해 실행 계획의 비용을 계산해서 최적의 1개 조합을 찾는 방법
  - 조인 테이블이 n개라면 n! 경우의 수 전부 찾음

### 9.3.2.2 Greedy 검색 알고리즘 (5.0~)
- 실행 순서
  1. 조인할 N개 테이블 중에 `optimizer_search_depth` 시스템 설정 변수 값의 개수로 가능한 조합 생성 (eg. 3개 테이블, depth: 2 -> 1.2, 1.3, 2.3)
  2. `1번` 과정에서 최소 비용 실행 계획 선정
  3. `1, 2번` 과정에서 선택된 테이블을 제외(N-1)개중 `1,2 번` 과정을 반복
  4. 조인 실행 계획 완성
- optimizer_search_depth 기본 값: 62
- 조인 개수가 `optimizer_search_depth`보다 클 경우: optimizer_search_depth값 만큼은 Exhaustive, 나머지 Greedy
- 조인 개수가 `optimizer_search_depth`보다 작을 경우: Exhaustive
- 값이 너무 크면 쿼리 성능에 영향을 미칠 수 있으니 4~5가 적당하다.
- `optimizer_purun_level` 시스템 변수는 heuristic 검색이 작동하는 방식을 제어
  - 여러 테이블의 조인 순서 비용을 계산하는 도중 계산했던 조인 순서의 비용보다 큰 경우 중간에 포기할 수 있는것 (eg. 처음은 100이었는데, 그 이후 조인 계산하다 100 넘으면 중단)


# 9.4 쿼리 힌트
MySQL이 성숙해지면서 통계 정보나 옵티마이저의 최적화 방법들이 고도화되면서 실행계획인 많이 최적화 되었다.<br>
하지만, 우리가 서비스하는 비지니스를 100% 이해하진 못한다.<br>
이때, 옵티마이저에게 쿼리의 실행 계획을 어떻게 수립해야할지 알려줄 수 있는 방법이 필요했다.<br>
MySQL에서 사용할 수 있는 힌트는 `인덱스 힌트`, `옵티마이저 힌트`등이 있다.

## 9.4.1 인덱스 힌트
- `STRAIGHT_JOIN`, `USE_INDEX` 등을 포함한 인덱스 힌트들은 MySQL 서버에 옵티마이저 힌트가 도입되기 전 사용하던 기능
  - 각각의 SQL 문법에 맞게 사용해야하기 때문에 ANSI_SQL 표준 문법을 준수하지 못하기 되는 단점이 있었음
    - ANSI_SQL: 미국 표준 협회에서 DBMS의 제약을 받지 않고 사용할 수 있는 SQL문법
  - 5.6 버전부터 추가되기 시작한 옵티마이저 힌트들은 MySQL 서버를 제외한 다른 RDBMS에선 주석으로 처리되어 ANSI_SQL 표준 준수
- SELECT, UPDATE에서 밖에 못씀
- 위의 이유때문에 인덱스 힌트보단 옵티마이저 힌트를 사용할 것을 추천

### 9.4.1.1 STRAIGHT_JOIN
- 옵티마이저 힌트인 동시에 조인 키워드
- 기본적으로 조인 순서는 인덱스 여부, 조건절의 레코드가 적은 순서대로 조인하지만, 옵티마이저가 실행계획을 잘못 세우는 경우 사용
- SELECT, UPDATE, DELETE 쿼리에서 여러개의 테이블이 조인되는 경우 조인 순서를 고정하는 역할을 함 (명시된 순서대로)

```sql
# 인덱스 힌트
select * STRAIGHT_JOIN 
from table1, table2, table3
~~~

# 옵티마이저 힌트
select * /*! STRAIGHT_JOIN */
from table1, table2, table3
```

- 유사한 힌트: `JOIN_FIXED_ORDER`, `JOIN_ORDER`, `JOIN_PREFIX`, `JOIN_SUFFIX`가 있다
  - `JOIN_FIXED_ORDER`는 `STRAIGHT_JOIN`과 동일한 효과(모든 테이블 순서), 나머지는 일부 테이블 조인 순서에 대해서만 제안

### 9.4.1.2 USE INDEX / FORCE INDEX / IGNORE INDEX
- 인덱스 힌트들이다.
- 인덱스 힌트는 인덱스를 가지는 테이블 뒤에 힌트를 명시해야한다.
- 대체로 옵티마이저가 잘 선택하는데 옵티마이저가 실수할 때 강제로 특정 인덱스를 사용하도록 하는 것
- USE INDEX: 특정 테이블의 인덱스를 사용하도록 권장하는 힌트(100% 사용하진 않음)
- FORCE INDEX: USE INDEX보다 강력한 권장. 하지만 USE INDEX를 사용했음에도 원하는 인덱스를 못타면 이거해도 못탈 확률 큼
- IGNORE INDEX: 특정 인덱스를 타지 못하도록 하는 용도
- 용도도 설정 해 줄수 있음(선택사항) eg. USE INDEX FOR (JOIN | ORDER BY | GROUP BY)
- 전문 검색 인덱스(full text search) 인덱스가 있는경우 다른 일반 보조 인덱스를 사용하지 않고 전문 검색 인덱스를 선택하는 경우가 많다.
- 하지만 이런 옵션을 사용하지 않고 옵티마이저가 당시 통계정보를 가지고 선택하게 하는것이 가장 좋음(데이터는 늘 바뀌기 때문)
